{
    "base.py": {
        "name": "base.py",
        "content": "## base.py\nfrom abc import ABCMeta, abstractmethod\nfrom dataclasses import dataclass, fields, replace\nfrom typing import Any, Optional, Dict\n\n\n\nclass BaseAnthropicTool(metaclass=ABCMeta):\n    \"\"\"Base class for all tools.\"\"\"\n\n    def __init__(self, input_schema: Optional[Dict[str, Any]] = None):\n        self.input_schema = input_schema or {\n            \"type\": \"object\",\n            \"properties\": {},\n            \"required\": []\n        }\n\n    @property\n    @abstractmethod\n    def name(self) -> str:\n        \"\"\"The name of the tool.\"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def description(self) -> str:\n        \"\"\"A description of what the tool does.\"\"\"\n        pass\n\n    @abstractmethod\n    def __call__(self, **kwargs) -> Any:\n        \"\"\"Execute the tool with the given arguments.\"\"\"\n        pass\n\n    def to_params(self) -> Dict[str, Any]:\n        \"\"\"Convert the tool to xAI API parameters.\"\"\"\n        return {\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": self.name,\n                \"description\": self.description,\n                \"parameters\": self.input_schema\n            }\n        }\n\n\n@dataclass(kw_only=True, frozen=True)\nclass ToolResult:\n    \"\"\"Represents the result of a tool execution.\"\"\"\n\n    output: Optional[str] = None\n    error: Optional[str] = None\n    base64_image: Optional[str] = None\n    system: Optional[str] = None\n\n    def __bool__(self):\n        return any(getattr(self, field.name) for field in fields(self))\n\n    def __add__(self, other: \"ToolResult\"):\n        def combine_fields(\n            field: str | None, other_field: str | None, concatenate: bool = True\n        ):\n            if field and other_field:\n                if concatenate:\n                    return field + other_field\n                raise ValueError(\"Cannot combine tool results\")\n            return field or other_field\n\n        return ToolResult(\n            output=combine_fields(self.output, other.output),\n            error=combine_fields(self.error, other.error),\n            base64_image=combine_fields(self.base64_image, other.base64_image, False),\n            system=combine_fields(self.system, other.system),\n        )\n\n    def replace(self, **kwargs):\n        \"\"\"Returns a new ToolResult with the given fields replaced.\"\"\"\n        return replace(self, **kwargs)\n\n\nclass CLIResult(ToolResult):\n    \"\"\"A ToolResult that can be rendered as a CLI output.\"\"\"\n    pass\n\n\nclass ToolFailure(ToolResult):\n    \"\"\"A ToolResult that represents a failure.\"\"\"\n    pass\n\n\n@dataclass(kw_only=True, frozen=True)\nclass ToolError(Exception):\n    \"\"\"Raised when a tool encounters an error.\"\"\"\n    message: str\n\n    def __init__(self, message: str):\n        object.__setattr__(self, 'message', message)\n        super().__init__(message)\n\n    def __str__(self):\n        return self.message",
        "version": 1,
        "last_modified": "2024-11-20T20:46:15.544541",
        "dependencies": [],
        "description": "A simple module"
    },
    "bash.py": {
        "name": "bash.py",
        "content": "## bash.py\nimport asyncio\nfrom typing import ClassVar, Literal\nfrom anthropic.types.beta import BetaToolBash20241022Param\n# from torch import error\nfrom .base import BaseAnthropicTool, CLIResult, ToolError, ToolResult\nimport platform\n# Using subprocess directly for shell commands\nfrom rich import print as rr\nclass BashTool(BaseAnthropicTool):\n    description=\"\"\"\n    A tool that allows the agent to run bash commands. On Windows it uses PowerShell\n    The tool parameters are defined by Anthropic and are not editable.\n    \"\"\"\n\n    name: ClassVar[Literal[\"bash\"]] = \"bash\"\n    api_type: ClassVar[Literal[\"bash_20241022\"]] = \"bash_20241022\"\n\n    async def __call__(\n        self, command: str | None = None, **kwargs\n    ):\n        if command is not None:\n             if platform.system() == 'Windows':\n                 \n                 command = f\"powershell.exe -command cd c:/repo && {command}\" # Run PowerShell commands on Windows\n             return await self._run_command(command)\n\n        raise ToolError(\"no command provided.\")\n\n    async def _run_command(self, command: str):\n        \"\"\"Execute a command in the shell.\"\"\"\n        try:\n            rr(command)\n            process = await asyncio.create_subprocess_shell(\n                command,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE,\n                shell=True\n            )\n            stdout, stderr = await process.communicate()\n\n            output = stdout.decode().strip() if stdout else \"\"\n            error = stderr.decode().strip() if stderr else None\n            rr(output)\n            if error:\n                rr(error)\n\n            return CLIResult(output=output, error=error)\n\n        except Exception as e:\n\n            return ToolResult(output=None, error=str(e))\n\n    def to_params(self) -> BetaToolBash20241022Param:\n        return {\n            \"type\": self.api_type,\n            \"name\": self.name,\n        }   \n    \n\n",
        "version": 1,
        "last_modified": "2024-11-20T20:46:15.544541",
        "dependencies": [],
        "description": "A simple module"
    },
    "bash_original.py": {
        "name": "bash_original.py",
        "content": "import asyncio\nimport os\nfrom typing import ClassVar, Literal\n\nfrom anthropic.types.beta import BetaToolBash20241022Param\n\nfrom .base import BaseAnthropicTool, CLIResult, ToolError, ToolResult\n\n\nclass _BashSession:\n    \"\"\"A session of a bash shell.\"\"\"\n\n    _started: bool\n    _process: asyncio.subprocess.Process\n\n    command: str = \"/bin/bash\"\n    _output_delay: float = 0.2  # seconds\n    _timeout: float = 120.0  # seconds\n    _sentinel: str = \"<<exit>>\"\n\n    def __init__(self):\n        self._started = False\n        self._timed_out = False\n\n    async def start(self):\n        if self._started:\n            return\n\n        self._process = await asyncio.create_subprocess_shell(\n            self.command,\n            preexec_fn=os.setsid,\n            shell=True,\n            bufsize=0,\n            stdin=asyncio.subprocess.PIPE,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n\n        self._started = True\n\n    def stop(self):\n        \"\"\"Terminate the bash shell.\"\"\"\n        if not self._started:\n            raise ToolError(\"Session has not started.\")\n        if self._process.returncode is not None:\n            return\n        self._process.terminate()\n\n    async def run(self, command: str):\n        \"\"\"Execute a command in the bash shell.\"\"\"\n        if not self._started:\n            raise ToolError(\"Session has not started.\")\n        if self._process.returncode is not None:\n            return ToolResult(\n                system=\"tool must be restarted\",\n                error=f\"bash has exited with returncode {self._process.returncode}\",\n            )\n        if self._timed_out:\n            raise ToolError(\n                f\"timed out: bash has not returned in {self._timeout} seconds and must be restarted\",\n            )\n\n        # we know these are not None because we created the process with PIPEs\n        assert self._process.stdin\n        assert self._process.stdout\n        assert self._process.stderr\n\n        # send command to the process\n        self._process.stdin.write(\n            command.encode() + f\"; echo '{self._sentinel}'\\n\".encode()\n        )\n        await self._process.stdin.drain()\n\n        # read output from the process, until the sentinel is found\n        try:\n            async with asyncio.timeout(self._timeout):\n                while True:\n                    await asyncio.sleep(self._output_delay)\n                    # if we read directly from stdout/stderr, it will wait forever for\n                    # EOF. use the StreamReader buffer directly instead.\n                    output = self._process.stdout._buffer.decode()  # pyright: ignore[reportAttributeAccessIssue]\n                    if self._sentinel in output:\n                        # strip the sentinel and break\n                        output = output[: output.index(self._sentinel)]\n                        break\n        except asyncio.TimeoutError:\n            self._timed_out = True\n            raise ToolError(\n                f\"timed out: bash has not returned in {self._timeout} seconds and must be restarted\",\n            ) from None\n\n        if output.endswith(\"\\n\"):\n            output = output[:-1]\n\n        error = self._process.stderr._buffer.decode()  # pyright: ignore[reportAttributeAccessIssue]\n        if error.endswith(\"\\n\"):\n            error = error[:-1]\n\n        # clear the buffers so that the next output can be read correctly\n        self._process.stdout._buffer.clear()  # pyright: ignore[reportAttributeAccessIssue]\n        self._process.stderr._buffer.clear()  # pyright: ignore[reportAttributeAccessIssue]\n\n        return CLIResult(output=output, error=error)\n\n\nclass BashTool(BaseAnthropicTool):\n    \"\"\"\n    A tool that allows the agent to run bash commands.\n    The tool parameters are defined by Anthropic and are not editable.\n    \"\"\"\n\n    _session: _BashSession | None\n    name: ClassVar[Literal[\"bash\"]] = \"bash\"\n    api_type: ClassVar[Literal[\"bash_20241022\"]] = \"bash_20241022\"\n\n    def __init__(self):\n        self._session = None\n        super().__init__()\n\n    async def __call__(\n        self, command: str | None = None, restart: bool = False, **kwargs\n    ):\n        if restart:\n            if self._session:\n                self._session.stop()\n            self._session = _BashSession()\n            await self._session.start()\n\n            return ToolResult(system=\"tool has been restarted.\")\n\n        if self._session is None:\n            self._session = _BashSession()\n            await self._session.start()\n\n        if command is not None:\n            return await self._session.run(command)\n\n        raise ToolError(\"no command provided.\")\n\n    def to_params(self) -> BetaToolBash20241022Param:\n        return {\n            \"type\": self.api_type,\n            \"name\": self.name,\n        }\n",
        "version": 1,
        "last_modified": "2024-11-20T20:46:15.545948",
        "dependencies": [],
        "description": "A simple module"
    },
    "code_context_manager.py": {
        "name": "code_context_manager.py",
        "content": "# code_context_manager.py\n\nimport os\nimport json\nimport re\nimport ast\nimport subprocess\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom typing import Dict, Set, Optional, List, Tuple\n\n@dataclass\nclass CodeFile:\n    name: str\n    content: str\n    version: int = 1\n    last_modified: datetime = field(default_factory=datetime.now)\n    dependencies: Set[str] = field(default_factory=set)\n    description: Optional[str] = None\n\n    def to_message(self) -> Dict[str, any]:\n        \"\"\"Convert CodeFile to a structured message for an LLM or any other consumer.\"\"\"\n        message_content = f\"\"\"\n        FILE CONTEXT:\n        **{self.name}** (v{self.version})\n        *Last Modified*: {self.last_modified.strftime('%Y-%m-%d %H:%M:%S')}\n        *Dependencies*: {', '.join(self.dependencies) if self.dependencies else 'None'}\n        *Description*: {self.description or 'No description provided.'}\n\n        **Content:**\n        ```python\n        {self.content}\n        ```\n        \"\"\"\n\n        return {\n            \"role\": \"user\",\n            \"content\": [{\n                \"type\": \"text\",\n                \"text\": message_content\n            }]\n        }\n\ndef extract_code_blocks(response_text: str) -> List[Tuple[str, str]]:\n    \"\"\"\n    Extracts code blocks from the response text.\n\n    Returns a list of tuples containing the language and code.\n    For example: [(\"python\", \"def foo(): pass\"), ...]\n    \"\"\"\n    code_blocks = []\n    # Regex to match code blocks with language specification\n    pattern = re.compile(r\"```(\\w+)?\\n([\\s\\S]*?)```\", re.MULTILINE)\n    matches = pattern.findall(response_text)\n    for lang, code in matches:\n        language = lang.strip() if lang else \"plaintext\"\n        code_blocks.append((language, code.strip()))\n    return code_blocks\n\ndef is_code_valid(code: str) -> bool:\n    \"\"\"\n    Checks if the provided Python code is syntactically correct.\n    \"\"\"\n    try:\n        ast.parse(code)\n        return True\n    except SyntaxError as e:\n        print(f\"SyntaxError while parsing code: {e}\")\n        return False\n\ndef replace_file(file_path: str, new_content: str) -> None:\n    \"\"\"\n    Replaces the entire content of the specified file with new_content.\n    \"\"\"\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.write(new_content)\n    print(f\"Replaced content of {file_path}\")\n\ndef insert_code_after_function(original_content: str, function_name: str, code_to_add: str) -> str:\n    \"\"\"\n    Inserts code after the specified function in a Python file.\n    \"\"\"\n    pattern = re.compile(rf\"(def {re.escape(function_name)}\\(.*?\\):\\s*[\\s\\S]*?)(?=def |\\Z)\", re.MULTILINE)\n    match = pattern.search(original_content)\n    if match:\n        insert_position = match.end()\n        return original_content[:insert_position] + '\\n\\n' + code_to_add + original_content[insert_position:]\n    else:\n        # If function not found, append at the end\n        return original_content + '\\n\\n' + code_to_add\n\ndef extract_single_code_block(code_block: str) -> Tuple[Optional[str], Optional[str]]:\n    \"\"\"\n    Extracts a single code block's language and code.\n    \"\"\"\n    match = re.match(r\"```(\\w+)?\\n([\\s\\S]*?)```\", code_block, re.MULTILINE)\n    if match:\n        lang = match.group(1).strip() if match.group(1) else \"plaintext\"\n        code = match.group(2).strip()\n        return lang, code\n    return None, None\n\ndef commit_changes(message: str) -> None:\n    \"\"\"\n    Commits changes to the git repository with the provided message.\n    \"\"\"\n    try:\n        subprocess.run([\"git\", \"add\", \".\"], check=True)\n        subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n        print(f\"Changes committed: {message}\")\n    except subprocess.CalledProcessError as e:\n        print(f\"Git commit failed: {e}\")\n\ndef run_tests() -> bool:\n    \"\"\"\n    Runs the test suite and returns True if all tests pass.\n    \"\"\"\n    try:\n        subprocess.run([\"pytest\"], check=True)\n        print(\"All tests passed.\")\n        return True\n    except subprocess.CalledProcessError:\n        print(\"Some tests failed.\")\n        return False\n\ndef revert_last_commit() -> None:\n    \"\"\"\n    Reverts the last git commit.\n    \"\"\"\n    try:\n        subprocess.run([\"git\", \"reset\", \"--hard\", \"HEAD~1\"], check=True)\n        print(\"Reverted the last commit.\")\n    except subprocess.CalledProcessError as e:\n        print(f\"Failed to revert commit: {e}\")\n\nclass CodeContextManager:\n    def __init__(self, persistence_file: Optional[str] = None):\n        self.files: Dict[str, CodeFile] = {}\n        self.persistence_file = persistence_file\n        if self.persistence_file:\n            self.load_from_disk()\n\n    def update_file(self, \n                   name: str, \n                   content: str, \n                   dependencies: Optional[Set[str]] = None, \n                   description: Optional[str] = None) -> None:\n        \"\"\"Add or update a file in the context.\"\"\"\n        if name in self.files:\n            existing_file = self.files[name]\n            existing_file.version += 1\n            existing_file.content = content\n            existing_file.last_modified = datetime.now()\n            if dependencies is not None:\n                existing_file.dependencies = dependencies\n            if description is not None:\n                existing_file.description = description\n            print(f\"Updated file: {name} to version {existing_file.version}\")\n        else:\n            self.files[name] = CodeFile(\n                name=name,\n                content=content,\n                dependencies=dependencies or set(),\n                description=description\n            )\n            print(f\"Added new file: {name}\")\n\n        if self.persistence_file:\n            self.save_to_disk()\n\n    def get_context_messages(self) -> List[Dict[str, any]]:\n        \"\"\"Get all file contexts as messages.\"\"\"\n        return [file.to_message() for file in self.files.values()]\n\n    def save_to_disk(self) -> None:\n        \"\"\"Persist the current code context to disk.\"\"\"\n        data = {\n            name: {\n                \"name\": file.name,\n                \"content\": file.content,\n                \"version\": file.version,\n                \"last_modified\": file.last_modified.isoformat(),\n                \"dependencies\": list(file.dependencies),\n                \"description\": file.description\n            } for name, file in self.files.items()\n        }\n        with open(self.persistence_file, 'w', encoding='utf-8') as f:\n            json.dump(data, f, indent=4)\n        print(f\"Saved code context to {self.persistence_file}\")\n\n    def load_from_disk(self) -> None:\n        \"\"\"Load the code context from disk.\"\"\"\n        if not os.path.exists(self.persistence_file):\n            print(f\"Persistence file {self.persistence_file} does not exist. Starting fresh.\")\n            return\n\n        with open(self.persistence_file, 'r', encoding='utf-8') as f:\n            data = json.load(f)\n            for name, file_data in data.items():\n                self.files[name] = CodeFile(\n                    name=file_data[\"name\"],\n                    content=file_data[\"content\"],\n                    version=file_data[\"version\"],\n                    last_modified=datetime.fromisoformat(file_data[\"last_modified\"]),\n                    dependencies=set(file_data[\"dependencies\"]),\n                    description=file_data.get(\"description\")\n                )\n        print(f\"Loaded code context from {self.persistence_file}\")\n\n    def remove_file(self, name: str) -> None:\n        \"\"\"Remove a file from the context.\"\"\"\n        if name in self.files:\n            del self.files[name]\n            print(f\"Removed file: {name}\")\n            if self.persistence_file:\n                self.save_to_disk()\n        else:\n            print(f\"Tried to remove non-existent file: {name}\")\n\n    def apply_llm_response(self, response_text: str) -> None:\n        \"\"\"\n        Parses the LLM response, extracts code blocks, and updates the relevant files.\n        Assumes the LLM follows a specific format to indicate target files and update types.\n\n        Example LLM response format:\n\n        ### Update file1.py\n        ```python\n        def greet(name, greeting=\"Hello\"):\n            return f\"{greeting}, {name}!\"\n        ```\n\n        ### Add to file2.py\n        ```python\n        def new_function():\n            pass\n        ```\n        \"\"\"\n        # Split the response into sections based on filenames\n        sections = re.split(r'###\\s+(?:Update|Add)\\s+(\\S+)', response_text)\n        \n        # The split will result in a list where filenames are captured in group 1\n        # Process in pairs: [text, filename, action, text, filename, action, ...]\n        it = iter(sections)\n        for section in it:\n            if not section.strip():\n                continue\n            # Get filename\n            filename = section.strip()\n            # Get action (assume that 'Update' or 'Add' was matched before the filename)\n            # Since regex does not capture action, infer it\n            action_match = re.search(r'###\\s+(Update|Add)\\s+', section)\n            action = \"full_replace\" if \"Update\" in section else \"add_code\"\n            \n            # Get the next item which should be the code block\n            try:\n                code_block = next(it).strip()\n                lang, code = extract_single_code_block(code_block)\n                if not code:\n                    print(f\"No code found in section for {filename}. Skipping.\")\n                    continue\n                if not is_code_valid(code):\n                    print(f\"Invalid code for {filename}. Skipping.\")\n                    continue\n\n                if action == \"full_replace\":\n                    self.replace_file_content(filename, code)\n                    commit_changes(f\"Replaced content of {filename}\")\n                elif action == \"add_code\":\n                    # Optionally, specify function or location\n                    # For simplicity, appending to the end\n                    self.add_code_to_file(filename, code)\n                    commit_changes(f\"Added code to {filename}\")\n                \n                # Run tests after each change\n                if run_tests():\n                    print(f\"Changes to {filename} passed tests.\")\n                else:\n                    print(f\"Tests failed after changes to {filename}. Reverting.\")\n                    revert_last_commit()\n            except StopIteration:\n                break\n\n    def replace_file_content(self, filename: str, new_content: str) -> None:\n        \"\"\"\n        Replaces the entire content of the specified file.\n        \"\"\"\n        file_path = os.path.join('code_files', filename)\n        if os.path.exists(file_path):\n            replace_file(file_path, new_content)\n            self.update_file(\n                name=filename,\n                content=new_content,\n                dependencies=self.extract_dependencies(new_content),\n                description=self.files[filename].description  # Keep existing description\n            )\n        else:\n            print(f\"File {filename} does not exist. Creating a new one.\")\n            replace_file(file_path, new_content)\n            self.update_file(\n                name=filename,\n                content=new_content,\n                dependencies=self.extract_dependencies(new_content),\n                description=\"Automatically created file.\"\n            )\n\n    def add_code_to_file(self, filename: str, code_to_add: str, function_name: Optional[str] = None) -> None:\n        \"\"\"\n        Adds new code to an existing file. Optionally, specify the function name for better placement.\n        \"\"\"\n        file_path = os.path.join('code_files', filename)\n        if not os.path.exists(file_path):\n            print(f\"File {filename} does not exist. Creating a new one.\")\n            replace_file(file_path, code_to_add)\n            self.update_file(\n                name=filename,\n                content=code_to_add,\n                dependencies=self.extract_dependencies(code_to_add),\n                description=\"Automatically created file.\"\n            )\n            return\n\n        with open(file_path, 'r', encoding='utf-8') as f:\n            original_content = f.read()\n\n        if function_name:\n            # Insert code after the specified function\n            updated_content = insert_code_after_function(original_content, function_name, code_to_add)\n        else:\n            # Append code at the end\n            updated_content = original_content + '\\n\\n' + code_to_add\n\n        replace_file(file_path, updated_content)\n\n        self.update_file(\n            name=filename,\n            content=updated_content,\n            dependencies=self.extract_dependencies(updated_content),\n            description=self.files[filename].description\n        )\n        print(f\"Added code to {filename}\")\n\n    def extract_dependencies(self, content: str) -> Set[str]:\n        \"\"\"\n        Extracts dependencies from the given Python file content.\n        \"\"\"\n        dependencies = set()\n        try:\n            tree = ast.parse(content)\n            for node in ast.walk(tree):\n                if isinstance(node, ast.Import):\n                    for alias in node.names:\n                        dependencies.add(alias.name.split('.')[0] + '.py')\n                elif isinstance(node, ast.ImportFrom):\n                    if node.module:\n                        dependencies.add(node.module.split('.')[0] + '.py')\n        except SyntaxError:\n            pass\n        # Filter dependencies to include only local files\n        return {dep for dep in dependencies if dep in self.files}\n",
        "version": 1,
        "last_modified": "2024-11-20T20:46:15.547264",
        "dependencies": [],
        "description": "A simple module"
    },
    "collection.py": {
        "name": "collection.py",
        "content": "## collection.py\n\"\"\"Collection classes for managing multiple tools.\"\"\"\n\nfrom typing import Any\nimport json\nfrom anthropic.types.beta import BetaToolUnionParam\nfrom icecream import ic\nfrom .base import (\n    BaseAnthropicTool,\n    ToolError,\n    ToolFailure,\n    ToolResult,\n)\nICECREAM_OUTPUT_FILE = \"debug_log.json\"\n\ndef write_to_file(s, file_path=ICECREAM_OUTPUT_FILE):\n    \"\"\"\n    Write debug output to a file, formatting JSON content in a pretty way.\n    \"\"\"\n    lines = s.split('\\n')\n    formatted_lines = []\n    \n    for line in lines:\n        if \"tool_input:\" in line:\n            try:\n                # Extract JSON part from the line\n                json_part = line.split(\"tool_input: \")[1]\n                # Parse and pretty-print the JSON\n                json_obj = json.loads(json_part)\n                pretty_json = json.dumps(json_obj, indent=4)\n                formatted_lines.append(\"tool_input: \" + pretty_json)\n            except (IndexError, json.JSONDecodeError):\n                # If parsing fails, just append the original line\n                formatted_lines.append(line)\n        else:\n            formatted_lines.append(line)\n    \n    # Write to file\n    with open(file_path, 'a', encoding=\"utf-8\") as f:\n        f.write('\\n'.join(formatted_lines))\n        f.write('\\n' + '-' * 80 + '\\n')  # Add separator between entries\n\nclass ToolCollection:\n    \"\"\"A collection of anthropic-defined tools.\"\"\"\n\n    def __init__(self, *tools: BaseAnthropicTool):\n        self.tools = tools\n        ic(self.tools)\n        self.tool_map = {tool.to_params()[\"name\"]: tool for tool in tools}\n        ic(self.tool_map)\n    def to_params(\n        self,\n    ) -> list[BetaToolUnionParam]:\n        ic()\n        params = [tool.to_params() for tool in self.tools]\n        if params:\n            params[-1][\"cache_control\"] = {\"type\": \"ephemeral\"}\n        return params\n\n    async def run(self, *, name: str, tool_input: dict[str, Any]) -> ToolResult:\n        ic.configureOutput(includeContext=True, outputFunction=write_to_file)\n\n        tool = self.tool_map.get(name)\n    \n        if not tool:\n            return ToolFailure(error=f\"Tool {name} is invalid\")\n        try:\n            ic(tool_input)\n            return await tool(**tool_input)\n        except ToolError as e:\n            return ToolFailure(error=e.message)\n#\"C:/repo/code_test/code_context_manager.py\"",
        "version": 1,
        "last_modified": "2024-11-20T20:46:15.547772",
        "dependencies": [],
        "description": "A simple module"
    },
    "computer.py": {
        "name": "computer.py",
        "content": "import asyncio\nimport base64\nimport os\nimport shlex\nimport shutil\nfrom enum import StrEnum\nfrom typing import Optional, Union, Tuple, Literal, TypedDict\nfrom pathlib import Path\nfrom uuid import uuid4\nimport pyautogui\nimport logging\nimport time\nimport pygetwindow as gw\nfrom PIL import Image\nfrom anthropic.types.beta import BetaToolComputerUse20241022Param\nimport pyperclip\nfrom .base import BaseAnthropicTool, CLIResult, ToolError, ToolResult\nfrom .run import run\n\nOUTPUT_DIR = os.path.join(os.getenv('APPDATA', ''), 'computer_tool', 'outputs')\n\nTYPING_DELAY_MS = 12\nTYPING_GROUP_SIZE = 50\n\nAction = Literal[\n    \"key\",\n    \"type\",\n    \"mouse_move\",\n    \"left_click\",\n    \"left_click_drag\",\n    \"right_click\",\n    \"middle_click\",\n    \"double_click\",\n    \"screenshot\",\n    \"cursor_position\",\n    # \"speak\",  # Add speak action\n    \"open_url\", # Add open_url action\n    \"get_window_title\", # Add get_window_title\n]\n\nclass Resolution(TypedDict):\n    width: int\n    height: int\n\n\n# sizes above XGA/WXGA are not recommended (see README.md)\n# scale down to one of these targets if ComputerTool._scaling_enabled is set\nMAX_SCALING_TARGETS: dict[str, Resolution] = {\n    \"XGA\": Resolution(width=1024, height=768),  # 4:3\n    \"WXGA\": Resolution(width=1280, height=800),  # 16:10\n    \"FWXGA\": Resolution(width=1366, height=768),  # ~16:9\n}\n\n\nclass ScalingSource(StrEnum):\n    COMPUTER = \"computer\"\n    API = \"api\"\n\nclass ComputerToolOptions(TypedDict):\n    display_height_px: int\n    display_width_px: int\n    display_number: Optional[int]\n\nclass ComputerTool(BaseAnthropicTool):\n    description=\"\"\"\n    A cross-platform tool that allows the agent to interact with the screen, keyboard, and mouse.\n    The tool parameters are defined by Anthropic and are not editable.\n    \"\"\"\n\n    name: Literal[\"computer\"] = \"computer\"\n    api_type: Literal[\"computer_20241022\"] = \"computer_20241022\"\n    width: int\n    height: int\n    display_num: int | None\n\n    _screenshot_delay = 1.0\n    _scaling_enabled = True\n\n    @property\n    def options(self) -> ComputerToolOptions:\n        width, height = self.scale_coordinates(\n            ScalingSource.COMPUTER, self.width, self.height\n        )\n        return {\n            \"display_width_px\": self.width,\n            \"display_height_px\": self.height,\n            \"display_number\": self.display_num,\n        }\n\n    def to_params(self) -> BetaToolComputerUse20241022Param:\n        return {\"name\": self.name, \"type\": self.api_type, **self.options}\n\n    def __init__(self):\n        super().__init__()\n        self.width = pyautogui.size().width\n        self.height = pyautogui.size().height\n        self.display_num = None\n        \n        os.makedirs(OUTPUT_DIR, exist_ok=True)\n\n    async def __call__(\n        self,\n        *,\n        action: Action,\n        text: Optional[str] = None,\n        coordinate: Optional[tuple[int, int]] = None,\n        **kwargs,\n    ) -> ToolResult:\n        try:\n            if action in (\"mouse_move\", \"left_click_drag\"):\n                if coordinate is None:\n                    raise ToolError(f\"coordinate is required for {action}\")\n                if text is not None:\n                    raise ToolError(f\"text is not accepted for {action}\")\n                if not isinstance(coordinate, (list, tuple)) or len(coordinate) != 2:\n                    raise ToolError(f\"{coordinate} must be a tuple of length 2\")\n                if not all(isinstance(i, int) and i >= 0 for i in coordinate):\n                    raise ToolError(f\"{coordinate} must be a tuple of non-negative ints\")\n\n                x, y = self.scale_coordinates(\n                    ScalingSource.API, coordinate[0], coordinate[1]\n                )\n\n                if action == \"mouse_move\":\n                    pyautogui.moveTo(x, y)\n                    return ToolResult(output=f\"Moved mouse to {x}, {y}\")\n                else:  # left_click_drag\n                    pyautogui.dragTo(x, y, button='left')\n                    return ToolResult(output=f\"Dragged mouse to {x}, {y}\")\n\n            if action in (\"key\", \"type\"):\n                if text is None:\n                    raise ToolError(f\"text is required for {action}\")\n                if coordinate is not None:\n                    raise ToolError(f\"coordinate is not accepted for {action}\")\n                if not isinstance(text, str):\n                    raise ToolError(f\"{text} must be a string\")\n\n                if action == \"key\":\n                    pyautogui.press(text)\n                    return ToolResult(output=f\"Pressed key: {text}\")\n                else:  # type\n                    pyautogui.write(text, interval=TYPING_DELAY_MS/1000)\n                    screenshot = await self.screenshot()\n                    return ToolResult(\n                        output=f\"Typed text: {text}\",\n                        base64_image=screenshot.base64_image\n                    )\n\n            if action in (\n                \"left_click\",\n                \"right_click\",\n                \"double_click\",\n                \"middle_click\",\n                \"screenshot\",\n                \"cursor_position\",\n            ):\n                if text is not None:\n                    raise ToolError(f\"text is not accepted for {action}\")\n                if coordinate is not None:\n                    raise ToolError(f\"coordinate is not accepted for {action}\")\n\n                if action == \"screenshot\":\n                    return await self.screenshot()\n\n                elif action == \"cursor_position\":\n                    pos = pyautogui.position()\n                    x, y = self.scale_coordinates(\n                        ScalingSource.COMPUTER, pos.x, pos.y\n                    )\n                    return ToolResult(output=f\"X={x},Y={y}\")\n                else:\n                    click_map = {\n                        \"left_click\": lambda: pyautogui.click(button='left'),\n                        \"right_click\": lambda: pyautogui.click(button='right'),\n                        \"middle_click\": lambda: pyautogui.click(button='middle'),\n                        \"double_click\": lambda: pyautogui.doubleClick(),\n                    }\n                    click_map[action]()\n                    return ToolResult(output=f\"Performed {action}\")\n\n            raise ToolError(f\"Invalid action: {action}\")\n\n        except Exception as e:\n            return ToolResult(error=str(e))\n\n    async def screenshot(self) -> ToolResult:\n        \"\"\"Take a screenshot of the current screen and return the base64 encoded image.\"\"\"\n        try:\n            path = Path(OUTPUT_DIR) / f\"screenshot_{uuid4().hex}.png\"\n            \n            # Take screenshot\n            screen = pyautogui.screenshot()\n            \n            # Scale if enabled\n            if self._scaling_enabled:\n                x, y = self.scale_coordinates(\n                    ScalingSource.COMPUTER, self.width, self.height\n                )\n                screen = screen.resize((x, y), Image.Resampling.LANCZOS)\n            \n            # Save and encode\n            screen.save(str(path))\n            base64_image = base64.b64encode(path.read_bytes()).decode()\n            \n            # Clean up old files\n            self._cleanup_screenshots()\n            \n            return ToolResult(\n                output=\"Screenshot taken\",\n                base64_image=base64_image\n            )\n        except Exception as e:\n            return ToolResult(error=f\"Failed to take screenshot: {str(e)}\")\n\n    def _cleanup_screenshots(self, max_files: int = 100):\n        \"\"\"Clean up old screenshots, keeping only the most recent ones.\"\"\"\n        try:\n            screenshots = sorted(\n                Path(OUTPUT_DIR).glob(\"*.png\"),\n                key=lambda x: x.stat().st_mtime\n            )\n            if len(screenshots) > max_files:\n                for screenshot in screenshots[:-max_files]:\n                    screenshot.unlink()\n        except Exception as e:\n            logging.warning(f\"Error cleaning up screenshots: {e}\")\n\n    def scale_coordinates(self, source: ScalingSource, x: int, y: int):\n        \"\"\"Scale coordinates to a target maximum resolution.\"\"\"\n        if not self._scaling_enabled:\n            return x, y\n        ratio = self.width / self.height\n        target_dimension = None\n        for dimension in MAX_SCALING_TARGETS.values():\n            # allow some error in the aspect ratio - not ratios are exactly 16:9\n            if abs(dimension[\"width\"] / dimension[\"height\"] - ratio) < 0.02:\n                if dimension[\"width\"] < self.width:\n                    target_dimension = dimension\n                break\n        if target_dimension is None:\n            return x, y\n        # should be less than 1\n        x_scaling_factor = target_dimension[\"width\"] / self.width\n        y_scaling_factor = target_dimension[\"height\"] / self.height\n        if source == ScalingSource.API:\n            if x > self.width or y > self.height:\n                raise ToolError(f\"Coordinates {x}, {y} are out of bounds\")\n            # scale up\n            return round(x / x_scaling_factor), round(y / y_scaling_factor)\n        # scale down\n        return round(x * x_scaling_factor), round(y * y_scaling_factor)\n",
        "version": 1,
        "last_modified": "2024-11-20T20:46:15.552032",
        "dependencies": [],
        "description": "A simple module"
    },
    "edit.py": {
        "name": "edit.py",
        "content": "## edit.py\nimport os\nimport re\nfrom pathlib import Path\nfrom collections import defaultdict\nfrom typing import Literal, get_args\nfrom anthropic.types.beta import BetaToolTextEditor20241022Param\nfrom .base import BaseAnthropicTool, ToolError, ToolResult\nfrom .run import maybe_truncate\nfrom typing import List, Optional\nfrom icecream import ic\nimport sys\nfrom rich import print as rr\n# Reconfigure stdout to use UTF-8 encoding\nsys.stdout.reconfigure(encoding='utf-8')\n# include the context for the icecream debugger\nic.configureOutput(includeContext=True)\n\n# Reconfigure stdout to use UTF-8 encoding\nCommand = Literal[\n    \"view\",\n    \"create\",\n    \"str_replace\",\n    \"insert\",\n    \"undo_edit\",\n]\nSNIPPET_LINES: int = 4\n\nclass EditTool(BaseAnthropicTool):\n    description=\"\"\"\n    A cross-platform filesystem editor tool that allows the agent to view, create, and edit files.\n    The tool parameters are defined by Anthropic and are not editable.\n    \"\"\"\n\n    api_type: Literal[\"text_editor_20241022\"] = \"text_editor_20241022\"\n    name: Literal[\"str_replace_editor\"] = \"str_replace_editor\"\n\n    _file_history: dict[Path, list[str]]\n\n    def __init__(self):\n        self._file_history = defaultdict(list)\n        super().__init__()\n\n    def to_params(self) -> BetaToolTextEditor20241022Param:\n        return {\n            \"name\": self.name,\n            \"type\": self.api_type,\n        }\n\n    async def __call__(\n        self,\n        *,\n        command: Command,\n        path: str,\n        file_text: str | None = None,\n        view_range: list[int] | None = None,\n        old_str: str | None = None,\n        new_str: str | None = None,\n        insert_line: int | None = None,\n        **kwargs,\n    ) -> ToolResult:\n\n        _path = Path(path).resolve()  # resolve() handles both Windows and Unix paths\n        ic(_path)\n\n        # _path = self.validate_path(command, _path)\n        if command == \"view\":\n            return await self.view(_path, view_range)\n        elif command == \"create\":\n            if not file_text:\n                raise ToolError(\"Parameter `file_text` is required for command: create\")\n            self.write_file(_path, file_text)\n            self._file_history[_path].append(file_text)\n            return ToolResult(output=f\"File created successfully at: {_path}\")\n        elif command == \"str_replace\":\n            if not old_str:\n                raise ToolError(\"Parameter `old_str` is required for command: str_replace\")\n            return self.str_replace(_path, old_str, new_str)\n        elif command == \"insert\":\n            if insert_line is None:\n                raise ToolError(\"Parameter `insert_line` is required for command: insert\")\n            if not new_str:\n                raise ToolError(\"Parameter `new_str` is required for command: insert\")\n            return self.insert(_path, insert_line, new_str)\n        elif command == \"undo_edit\":\n            return self.undo_edit(_path)\n        raise ToolError(\n            f'Unrecognized command {command}. The allowed commands for the {self.name} tool are: {\", \".join(get_args(Command))}'\n        )\n    def normalize_path(self, path: Optional[str]) -> Path:\n        \"\"\"\n        Normalize a file path to ensure it starts with 'C:/repo/'.\n        \n        Args:\n            path: Input path string that needs to be normalized\n            Note:\n            This method is used to normalize the path provided by the user.\n            The normalized path is used to ensure that the path starts with 'C:/repo/'\n            and is a valid path.\n        Returns:\n            Normalized path string starting with 'C:/repo/'\n            \n        Raises:\n            ValueError: If the path is None or empty\n        \"\"\"\n        if not path:\n            raise ValueError('Path cannot be empty')\n        \n        # Convert to string in case we receive a Path object\n        normalized_path = str(path)\n        \n        # Convert all backslashes to forward slashes\n        normalized_path = normalized_path.replace('\\\\', '/')\n        \n        # Remove any leading/trailing whitespace\n        normalized_path = normalized_path.strip()\n        \n        # Remove multiple consecutive forward slashes\n        normalized_path = re.sub(r'/+', '/', normalized_path)\n        \n        # Remove 'C:' or 'c:' if it exists at the start\n        normalized_path = re.sub(r'^[cC]:', '', normalized_path)\n        \n        # Remove '/repo/' if it exists at the start\n        normalized_path = re.sub(r'^/repo/', '', normalized_path)\n        \n        # Remove leading slash if it exists\n        normalized_path = re.sub(r'^/', '', normalized_path)\n        \n        # Combine with base path\n        return Path(f'C:/repo/{normalized_path}')\n\n    def validate_path(self, command: str, path: Path):\n        \"\"\"\n        Check that the path/command combination is valid in a cross-platform manner.\n        param command: The command that the user is trying to run.\n        \"\"\"\n        path = self.normalize_path(path)\n        try:\n            # This handles both Windows and Unix paths correctly\n            path = path.resolve()\n        except Exception as e:\n            raise ToolError(f\"Invalid path format: {path}. Error: {str(e)}\")\n\n        # Check if it's an absolute path\n        if not path.is_absolute():\n            suggested_path = Path.cwd() / path\n            raise ToolError(\n                f\"The path {path} is not an absolute path. Maybe you meant {suggested_path}?\"\n            )\n\n        # Check if path exists\n        if not path.exists() and command != \"create\":\n            raise ToolError(\n                f\"The path {path} does not exist. Please provide a valid path.\"\n            )\n        if path.exists() and command == \"create\":\n            raise ToolError(\n                f\"File already exists at: {path}. Cannot overwrite files using command `create`.\"\n            )\n\n        # Check if the path points to a directory\n        if path.is_dir():\n            if command != \"view\":\n                raise ToolError(\n                    f\"The path {path} is a directory and only the `view` command can be used on directories\"\n                )\n    async def view(self, path: Path, view_range: Optional[List[int]] = None) -> ToolResult:\n        \"\"\"Implement the view command using cross-platform methods.\"\"\"\n        ic(path)\n        path = self.normalize_path(path)\n        if path.is_dir():\n            if view_range:\n                raise ToolError(\n                    \"The `view_range` parameter is not allowed when `path` points to a directory.\"\n                )\n\n            try:\n                # Cross-platform directory listing using pathlib\n                files = []\n                for level in range(3):  # 0-2 levels deep\n                    if level == 0:\n                        pattern = \"*\"\n                    else:\n                        pattern = os.path.join(*[\"*\"] * (level + 1))\n\n                    for item in path.glob(pattern):\n                        # Skip hidden files and directories\n                        if not any(part.startswith('.') for part in item.parts):\n                            files.append(str(item.resolve()))  # Ensure absolute paths\n\n                stdout = \"\\n\".join(sorted(files))\n                stdout = f\"Here's the files and directories up to 2 levels deep in {path}, excluding hidden items:\\n{stdout}\\n\"\n                return ToolResult(output=stdout, error=None, base64_image=None)\n            except Exception as e:\n                return ToolResult(output=\"\", error=str(e), base64_image=None)\n\n        # If it's a file, read its content\n        file_content = self.read_file(path)\n        init_line = 1\n        if view_range:\n            if len(view_range) != 2 or not all(isinstance(i, int) for i in view_range):\n                raise ToolError(\"Invalid `view_range`. It should be a list of two integers.\")\n            file_lines = file_content.split(\"\\n\")\n            n_lines_file = len(file_lines)\n            init_line, final_line = view_range\n            if init_line < 1 or init_line > n_lines_file:\n                raise ToolError(\n                    f\"Invalid `view_range`: {view_range}. Its first element `{init_line}` should be within the range of lines of the file: {[1, n_lines_file]}\"\n                )\n            if final_line > n_lines_file:\n                raise ToolError(\n                    f\"Invalid `view_range`: {view_range}. Its second element `{final_line}` should be smaller than the number of lines in the file: `{n_lines_file}`\"\n                )\n            if final_line != -1 and final_line < init_line:\n                raise ToolError(\n                    f\"Invalid `view_range`: {view_range}. Its second element `{final_line}` should be larger or equal than its first `{init_line}`\"\n                )\n\n            if final_line == -1:\n                file_content = \"\\n\".join(file_lines[init_line - 1:])\n            else:\n                file_content = \"\\n\".join(file_lines[init_line - 1 : final_line])\n        ic(file_content)\n        return ToolResult(output=self._make_output(file_content, str(path), init_line=init_line), error=None, base64_image=None)\n    def str_replace(self, path: Path, old_str: str, new_str: Optional[str]) -> ToolResult:\n        \"\"\"Implement the str_replace command, which replaces old_str with new_str in the file content.\"\"\"\n        try:\n            # Read the file content\n            ic(path)\n            path = self.normalize_path(path)\n            file_content = self.read_file(path).expandtabs()\n            old_str = old_str.expandtabs()\n            new_str = new_str.expandtabs() if new_str is not None else \"\"\n\n            # Check if old_str is unique in the file\n            occurrences = file_content.count(old_str)\n            if occurrences == 0:\n                raise ToolError(f\"No replacement was performed, old_str `{old_str}` did not appear verbatim in {path}.\")\n            elif occurrences > 1:\n                file_content_lines = file_content.split(\"\\n\")\n                lines = [\n                    idx + 1\n                    for idx, line in enumerate(file_content_lines)\n                    if old_str in line\n                ]\n                raise ToolError(\n                    f\"No replacement was performed. Multiple occurrences of old_str `{old_str}` in lines {lines}. Please ensure it is unique\"\n                )\n\n            # Replace old_str with new_str\n            new_file_content = file_content.replace(old_str, new_str)\n\n            # Write the new content to the file\n            self.write_file(path, new_file_content)\n\n            # Save the content to history\n            self._file_history[path].append(file_content)\n\n            # Create a snippet of the edited section\n            replacement_line = file_content.split(old_str)[0].count(\"\\n\")\n            start_line = max(0, replacement_line - SNIPPET_LINES)\n            end_line = replacement_line + SNIPPET_LINES + new_str.count(\"\\n\")\n            snippet = \"\\n\".join(new_file_content.split(\"\\n\")[start_line : end_line + 1])\n\n            # Prepare the success message\n            success_msg = f\"The file {path} has been edited. \"\n            success_msg += self._make_output(snippet, f\"a snippet of {path}\", start_line + 1)\n            success_msg += \"Review the changes and make sure they are as expected. Edit the file again if necessary.\"\n\n            return ToolResult(output=success_msg, error=None, base64_image=None)\n\n        except Exception as e:\n            return ToolResult(output=None, error=str(e), base64_image=None)\n    def insert(self, path: Path, insert_line: int, new_str: str) -> ToolResult:\n        \"\"\"Implement the insert command, which inserts new_str at the specified line in the file content.\"\"\"\n        path = self.normalize_path(path)\n        file_text = self.read_file(path).expandtabs()\n        new_str = new_str.expandtabs()\n        file_text_lines = file_text.split(\"\\n\")\n        n_lines_file = len(file_text_lines)\n\n        if insert_line < 0 or insert_line > n_lines_file:\n            raise ToolError(\n                f\"Invalid `insert_line` parameter: {insert_line}. It should be within the range of lines of the file: {[0, n_lines_file]}\"\n            )\n\n        new_str_lines = new_str.split(\"\\n\")\n        new_file_text_lines = (\n            file_text_lines[:insert_line]\n            + new_str_lines\n            + file_text_lines[insert_line:]\n        )\n        snippet_lines = (\n            file_text_lines[max(0, insert_line - SNIPPET_LINES) : insert_line]\n            + new_str_lines\n            + file_text_lines[insert_line : insert_line + SNIPPET_LINES]\n        )\n\n        new_file_text = \"\\n\".join(new_file_text_lines)\n        snippet = \"\\n\".join(snippet_lines)\n\n        self.write_file(path, new_file_text)\n        self._file_history[path].append(file_text)\n\n        success_msg = f\"The file {path} has been edited. \"\n        success_msg += self._make_output(\n            snippet,\n            \"a snippet of the edited file\",\n            max(1, insert_line - SNIPPET_LINES + 1),\n        )\n        success_msg += \"Review the changes and make sure they are as expected (correct indentation, no duplicate lines, etc). Edit the file again if necessary.\"\n        return ToolResult(output=success_msg)\n    def ensure_valid_repo_path(filename: str) -> str:\n        ### Need to Try this out ###\n        base_path = \"C:/repo/\"\n        \n        # Normalize path separators for cross-platform compatibility\n        filename = filename.replace(\"\\\\\", \"/\")\n        \n        # Check if the filename already starts with the base path\n        if not filename.startswith(base_path):\n            # Prepend the base path if it's not present\n            filename = os.path.join(base_path, filename.lstrip(\"/\"))\n        filename = self.normalize_path(filename)\n        # Return the standardized path using Windows-style separator\n        return os.path.normpath(filename)\n    def undo_edit(self, path: Path) -> ToolResult:\n        \"\"\"Implement the undo_edit command.\"\"\"\n        path = self.normalize_path(path)\n        if not self._file_history[path]:\n            raise ToolError(f\"No edit history found for {path}.\")\n\n        old_text = self._file_history[path].pop()\n        self.write_file(path, old_text)\n\n        return ToolResult(\n            output=f\"Last edit to {path} undone successfully. {self._make_output(old_text, str(path))}\"\n        )\n\n    def read_file(self, path: Path) -> str:\n        rr(path)\n\n        path = self.normalize_path(path)\n\n        try:\n            return path.read_text(encoding=\"utf-8\").encode('ascii', errors='replace').decode('ascii')\n        except Exception as e:\n            ic(f\"Error reading file {path}: {e}\")\n            raise ToolError(f\"Ran into {e} while trying to read {path}\") from None\n    def write_file(self, path: Path, file: str):\n        path = self.normalize_path(path)\n        \"\"\"Write the content of a file to a given path; raise a ToolError if an error occurs.\"\"\"\n        try:\n            path.write_text(file, encoding=\"utf-8\")\n        except Exception as e:\n            raise ToolError(f\"Ran into {e} while trying to write to {path}\") from None\n\n    def _make_output(\n        self,\n        file_content: str,\n        file_descriptor: str,\n        init_line: int = 1,\n        expand_tabs: bool = True,\n    ) -> str:\n        \"\"\"Generate output for the CLI based on the content of a file.\"\"\"\n        file_content = maybe_truncate(file_content)\n        if expand_tabs:\n            file_content = file_content.expandtabs()\n        file_content = \"\\n\".join(\n            [\n                f\"{i + init_line:6}\\t{line}\"\n                for i, line in enumerate(file_content.split(\"\\n\"))\n            ]\n        )\n        return (\n            f\"Here's the result of running ` -n` on {file_descriptor}:\\n\"\n            + file_content\n            + \"\\n\"\n        )\n",
        "version": 1,
        "last_modified": "2024-11-20T20:46:15.553646",
        "dependencies": [],
        "description": "A simple module"
    },
    "example_tool.py": {
        "name": "example_tool.py",
        "content": "from .base import BaseAnthropicTool\n\nclass ExampleTool(BaseAnthropicTool):\n    @property\n    def name(self) -> str:\n        return \"example_tool\"\n\n    @property\n    def description(self) -> str:\n        return \"An example tool that does something.\"\n\n    def __init__(self):\n        super().__init__(input_schema={\n            \"type\": \"object\",\n            \"properties\": {\n                \"example_param\": {\n                    \"type\": \"string\",\n                    \"description\": \"An example parameter for the tool.\"\n                }\n            },\n            \"required\": [\"example_param\"]\n        })\n\n    def __call__(self, **kwargs) -> str:\n        # Implement the tool's functionality here\n        return f\"Example tool executed with {kwargs.get('example_param')}\" ",
        "version": 1,
        "last_modified": "2024-11-20T20:46:15.554657",
        "dependencies": [],
        "description": "A simple module"
    },
    "expert.py": {
        "name": "expert.py",
        "content": "#expert.py\nfrom openai import OpenAI\n# load the API key from the environment\nfrom dotenv import load_dotenv\nfrom icecream import ic\nfrom typing import Optional, Literal\nfrom .base import ToolError, ToolResult, BaseAnthropicTool, ToolFailure\nload_dotenv()\nfrom rich import print as rr\n\n\nclass GetExpertOpinionTool(BaseAnthropicTool):\n    \"\"\"\n    A tool takes a detailed description of the problem and everything that has been tried so far, and returns an expert opinion on the problem.\n    \"\"\"\n\n    name: Literal[\"Opinion\"] = \"opinion\"\n    api_type: Literal[\"custom\"] = \"custom\"\n    description: str = \"A tool takes a detailed description of the problem and everything that has been tried so far, and returns an expert opinion on the problem.\"\n\n\n\n    def to_params(self) -> dict:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"type\": self.api_type,\n            \"input_schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"command\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"get_opinion\"],\n                        \"description\": \"The command to get an expert opinion.\"\n                    },\n                    \"problem_description\": {\n                        \"type\": \"string\",\n                        \"description\": \"A detailed description of the problem and everything that has been tried so far. If for programming, include the code that has been tried.\"\n                    }\n                },\n                \"required\": [\"command\", \"problem_description\"]\n            }\n        }\n        \n    async def __call__(     \n        self,\n        *,\n        command: Literal[\"get_opinion\"],\n        problem_description: Optional[str] = None,\n        **kwargs,\n    ) -> ToolResult:\n        \"\"\"\n        Executes the specified command.\n        \"\"\"\n       \n        if command == \"get_opinion\":\n            ic()\n            return await self.get_opinion(problem_description=problem_description)\n        if command == \"get_plan\":\n            ic()\n            return await self.get_plan(problem_description=problem_description)\n        else:\n            ic()\n            raise ToolError(\n                f\"Unrecognized command '{command}'. Allowed commands: 'list_reports', 'run_report'.\"\n            )\n\n    async def get_plan(self, problem_description) -> ToolResult:\n        prompt = f\"\"\"\n        Objective:\nYou are a Task Decomposition Specialist. Your goal is to meticulously break down any given computer-based task into the smallest reasonable steps. Each step should be clear, actionable, and independently verifiable for completion by someone without prior knowledge of the task or access to the execution environment.\nInstructions:\nFor each step (and sub-step, if necessary), provide the following:\nStep [Number]:\nAction: A detailed and specific description of the action to be performed.\nExpected Result: A description of what should occur or be produced after the action is completed.\nVerification Method: A precise method to confirm that the step has been completed, which should:\nBe executable by someone who has not seen the previous steps.\nNot require access to the environment where the task was performed.\nFocus on confirming the completion of the action, not the accuracy of the result (unless completion inherently requires accuracy).\nGuidelines:\nClarity and Specificity:\nUse clear, unambiguous language.\nInclude specific details such as file names, URLs, commands, or search queries where applicable.\nStep Structure:\nMain Steps: Numbered sequentially (e.g., Step 1, Step 2, Step 3).\nSub-Steps: If a step requires multiple actions, break it down into sub-steps (e.g., Sub-Step 1.1, Sub-Step 1.2).\nFormatting Requirements:\nUse bold headings for Action, Expected Result, and Verification Method for clarity.\nPresent information in a structured and organized manner.\nIndependent Verification:\nEnsure each verification method can be performed independently of other steps.\nVerification should rely only on the outputs or artifacts produced by that specific step.\nVerification Methods:\nShould be objective, measurable, and specific.\nMay include:\nChecking the existence or properties of a file or document.\nViewing metadata, timestamps, or file contents.\nConfirming the presence of specific data, entries, or outputs.\nReviewing screenshots or exported logs.\nNo Assumptions:\nDo not assume the verifier has any prior knowledge of the task or access to previous results.\nDo not require the verifier to access the execution environment or external systems beyond what is produced in the step.\nExample Format:\nStep 1:\nAction: Create a new folder named Elevator_Project on your desktop.\nExpected Result: A folder named Elevator_Project exists on the desktop.\nVerification Method: Check the desktop for the presence of the Elevator_Project folder.\nSub-Step 1.1:\nAction: Inside the Elevator_Project folder, create an Excel file named elevator_data.xlsx with two sheets labeled Company_Info and Models.\nExpected Result: An Excel file elevator_data.xlsx with two sheets named Company_Info and Models exists in the Elevator_Project folder.\nVerification Method: Open elevator_data.xlsx and confirm the sheets Company_Info and Models are present.\nSub-Step 1.2:\nAction: In the Company_Info sheet, add column headers in the first row: Manufacturer, Public/Private, Number of Employees, Years in Business.\nExpected Result: The Company_Info sheet has the specified headers correctly labeled in the first row.\nVerification Method: Open the Company_Info sheet and verify the headers are present and correctly labeled.\nYour Task:\n{problem_description}\nApply the above guidelines and format to break down the provided task:\nInstructions for Completion:\nIdentify Main Steps:\nStart by outlining the major components required to complete the task.\nDecompose into Sub-Steps:\nBreak down each main step into smaller, actionable sub-steps as necessary.\nDetail Each Step:\nFor every step and sub-step, provide the Action, Expected Result, and Verification Method as per the guidelines.\nEnsure Independent Verification:\nMake sure that each verification method allows someone to confirm completion without prior knowledge or access to the execution environment.\nMaintain Clarity and Organization:\nUse the specified formatting for consistency and ease of understanding.\nBegin your detailed task breakdown below:\n        \"\"\"\n        return ToolResult(output=prompt)\n\n    async def get_opinion(self, problem_description) -> ToolResult:\n        \"\"\"\n        Lists all available reports.\n        \"\"\"\n        try:\n            ic()\n            client = OpenAI()\n            ic(client)\n            prompt = f\"\"\"\n           The user would like your expert opinion on the following problem:\n           {problem_description}\n            \"\"\"\n            rr(problem_description)\n            response = client.chat.completions.create(\n                model=\"o1-preview\",\n                messages=[\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"text\",\n                                \"text\": prompt\n                            },\n                        ],\n                    }\n                ]\n            )\n            ic(response)\n            ex_opinion = response.choices[0].message.content\n            return ToolResult(output=ex_opinion)\n        except Exception as e:\n            ic(e)\n            rr(f\"{str(e).encode('ascii', errors='replace').decode('ascii')}\")\n            return ToolFailure(error=\"Failed to generate opinion.\")\n\n\n\n\n\n\n\n",
        "version": 1,
        "last_modified": "2024-11-20T20:46:15.556822",
        "dependencies": [],
        "description": "A simple module"
    },
    "gotourl_reports.py": {
        "name": "gotourl_reports.py",
        "content": "import difflib\nimport pandas as pd\nfrom typing import Optional, Literal, TypedDict\n# from tools import ToolResult, , BaseAnthropicTool  # Adjust the import path as necessary\nfrom enum import StrEnum\nfrom .base import ToolError, ToolResult, BaseAnthropicTool\nfrom icecream import ic\nfrom playwright.async_api import async_playwright\nimport os\nclass Resolution(TypedDict):\n    width: int\n    height: int\nfrom rich import print as rr\n\nclass ScalingSource(StrEnum):\n    COMPUTER = \"computer\"\n    API = \"api\"\n\nclass Options(TypedDict):\n    display_height_px: int\n    display_width_px: int\n    display_number: Optional[int]\n\nclass GoToURLReportsTool(BaseAnthropicTool):\n    \"\"\"\n    A tool that allows the agent to list available reports and run a selected report\n    from the Auto Chlor System Web Portal.\n    \"\"\"\n\n    name: Literal[\"reports\"] = \"reports\"\n    api_type: Literal[\"custom\"] = \"custom\"\n    description: str = \"A tool that allows the agent to list available reports and run a selected report from the Auto Chlor System Web Portal.\"\n    height: int\n    display_num: Optional[int]\n\n    _screenshot_delay = 1.0\n    _scaling_enabled = True\n\n    @property\n    def options(self) -> Options:\n        return {\n            \"display_width_px\": self.width,\n            \"display_height_px\": self.height,\n            \"display_number\": self.display_num,\n        }\n\n    def to_params(self) -> dict:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"type\": self.api_type,\n            \"input_schema\": {  # Use parameters instead of custom.input_schema\n                \"type\": \"object\",\n                \"properties\": {\n                    \"command\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"list_reports\", \"run_report\"],\n                        \"description\": \"The command to execute. Either 'list_reports' to list all reports or 'run_report' to execute a specific report.\"\n                    },\n                    \"report_name\": {\n                        \"type\": \"string\",\n                        \"description\": \"The name of the report to run. Required if command is 'run_report'.\"\n                    }\n                },\n                \"required\": [\"command\"],\n            }\n        }\n        \n    async def __call__(     \n        self,\n        *,\n        command: Literal[\"list_reports\", \"run_report\"],\n        report_name: Optional[str] = None,\n        **kwargs,\n    ) -> ToolResult:\n        \"\"\"\n        Executes the specified command.\n        \"\"\"\n        if command == \"list_reports\":\n            return await self.list_reports()\n        elif command == \"run_report\":\n            if not report_name:\n                raise ToolError(\"Parameter `report_name` is required for command: run_report\")\n            return await self.run_report(report_name)\n        else:\n            raise ToolError(\n                f\"Unrecognized command '{command}'. Allowed commands: 'list_reports', 'run_report'.\"\n            )\n\n    async def list_reports(self) -> ToolResult:\n        \"\"\"\n        Lists all available reports.\n        \"\"\"\n        try:\n            # Example: Replace with your actual data source\n            df = pd.read_csv(r\"C:\\Users\\Machine81\\code\\anthropic-quickstarts\\computer-use-demo\\computer_use_demo\\filtered_links.csv\")  # Ensure this path is correct\n            report_list = \"\\n\".join(f\"- {name}\" for name in df['display_name'])\n            # ic(report_list)\n            return ToolResult(output=f\"Available Reports:\\n{report_list}\")\n        except Exception as e:\n            raise ToolError(f\"Failed to list reports: {str(e)}\")\n\n    async def run_report(self, report_name: str) -> ToolResult:\n        \"\"\"\n        Runs the specified report by finding the closest match and opening the URL.\n        \"\"\"\n        try:\n            # Example: Replace with your actual data source\n            df = pd.read_csv(r\"C:\\Users\\Machine81\\code\\anthropic-quickstarts\\computer-use-demo\\computer_use_demo\\filtered_links.csv\")  # Ensure this path is correct\n            ic(df.head())\n            # replace _ with space in report_name\n            report_name = report_name.replace(\"_\", \" \")\n            rr(report_name)\n            matches = difflib.get_close_matches(report_name, df['display_name'], n=1, cutoff=0.1,)\n            ic(matches)\n            if not matches:\n                raise ToolError(f\"No matching report found for '{report_name}'.\")\n\n            best_match = matches[0]\n\n            url_suffix = df.loc[df['display_name'] == best_match, 'url'].iloc[0]\n            full_url = f\"https://www.autochlor.net/wps/{url_suffix}\"\n            async with async_playwright() as p:\n                browser = await p.chromium.launch(headless=False)\n                context = await browser.new_context(storage_state=r\"C:\\mygit\\compuse\\computer_use_demo\\state.json\")\n                page = await context.new_page()\n                await page.goto(full_url)\n                # press the PRINT button\n                page.click('input[type=\"submit\"][value=\"PRINT\"]')\n\n            return ToolResult(output=\"That report is available \")\n        except Exception as e:\n            raise ToolError(f\"Failed to run report '{report_name}': {str(e)}\")\n        \n\n\n    async def download_file(self, url: str):\n\n        # Initialize Playwright\n        async with async_playwright() as p:\n            # Launch Chromium with specified user data directory\n            browser = await p.chromium.launch(channel=\"chrome\", headless=False)\n            context = browser.new_context(storage_state=r\"C:\\mygit\\compuse\\computer_use_demo\\state.json\")\n            # Navigate to page (state will be preserved)\n            page.goto('https://www.autochlor.net/wps')\n            \n            # Verify state is loaded\n            cookies = context.cookies()\n            local_storage = page.evaluate(\"\"\"() => {\n                return Object.entries(localStorage);\n            }\"\"\")\n            \n \n            # Open a new page\n            page = await browser.new_page()\n\n            await page.goto(url)\n\n            # Directory to save downloads\n            download_path = os.path.join(os.getcwd(), \"downloads\")\n            os.makedirs(download_path, exist_ok=True)\n\n            for index, row in df.iterrows():\n                if row['url_type'] == 'File':\n                    file_url = base_url + row['url']\n                    rr(f\"Downloading from URL: {file_url}\")\n\n                    try:\n                        # Listen for the download event\n                        async with page.expect_download() as download_info:\n                            await page.goto(file_url)\n                        download = await download_info.value\n                        \n                        # Save the downloaded file to the specified path\n                        await download.save_as(os.path.join(download_path, download.suggested_filename))\n                        rr(f\"Downloaded: {download.suggested_filename}\")\n\n                    except Exception as e:\n                        rr(f\"Error downloading from URL: {file_url}\")\n                        rr(e)\n\n            # Close the browser after all downloads\n            await browser.close()   ",
        "version": 1,
        "last_modified": "2024-11-20T20:46:15.557822",
        "dependencies": [],
        "description": "A simple module"
    },
    "playwright.py": {
        "name": "playwright.py",
        "content": "#playwright.py\nimport os\nimport logging\nfrom playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeoutError\nfrom typing import Literal, Optional, Dict, Any, List\nimport requests\nfrom bs4 import BeautifulSoup, Comment  # Add Comment to the import\nimport re\nfrom .base import ToolResult\n# Configure logging for user feedback and debugging\nlogging.basicConfig(level=logging.CRITICAL, format='%(asctime)s - %(levelname)s - %(message)s')\n\nclass WebNavigatorTool:\n    \"\"\"\n    A versatile tool that uses Playwright to interact with the web, including reading information,\n    navigating websites, filling forms, extracting data, interacting with dynamic elements, and downloading files.\n    It also integrates with external APIs and includes enhanced error handling and #logging.\n    \"\"\"\n\n    name: Literal[\"web_navigator\"] = \"web_navigator\"\n    api_type: Literal[\"custom\"] = \"custom\"\n    description: str = (\n        \"A comprehensive tool that uses Playwright to perform various web interactions such as reading information, \"\n        \"navigating websites, filling out forms, extracting data, interacting with dynamic elements, and downloading files. \"\n        \"It also integrates with external APIs and includes enhanced error handling and logging for improved user experience.\"\n    )\n\n    def __init__(self, download_dir: Optional[str] = None, api_credentials: Optional[Dict[str, Any]] = None):\n        \"\"\"\n        Initializes the WebNavigatorTool with optional download directory and API credentials.\n        \"\"\"\n        self.download_dir = download_dir or os.path.join(os.getcwd(), \"downloads\")\n        os.makedirs(self.download_dir, exist_ok=True)\n        self.api_credentials = api_credentials or {}\n        self.session_history = []  # For contextual awareness\n        logging.info(\"WebNavigatorTool initialized with download directory at '%s'.\", self.download_dir)\n\n\n    def to_params(self) -> dict:\n        \"\"\"\n        Defines the parameters for the tool, specifying the input schema.\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"type\": self.api_type,\n            \"input_schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"url\": {\n                        \"type\": \"string\",\n                        \"description\": \"The URL to perform the action on.\"\n                    },\n                    \"action\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"read\", \"navigate\", \"download\", \"fill_form\", \"extract_data\", \"click_element\"],\n                        \"description\": \"The action to perform.\"\n                    },\n                    \"params\": {\n                        \"type\": \"object\",\n                        \"description\": \"Additional parameters required for the action.\",\n                        \"properties\": {\n                            \"file_path\": {\n                                \"type\": \"string\",\n                                \"description\": \"Path to save the downloaded file (required for 'download' action).\"\n                            },\n                            \"form_selector\": {\n                                \"type\": \"string\",\n                                \"description\": \"CSS selector for the form to fill (required for 'fill_form' action).\"\n                            },\n                            \"form_data\": {\n                                \"type\": \"object\",\n                                \"additionalProperties\": {\n                                    \"type\": \"string\"\n                                },\n                                \"description\": \"Data to fill into the form fields.\"\n                            },\n                            \"data_selector\": {\n                                \"type\": \"string\",\n                                \"description\": \"CSS selector for data extraction (required for 'extract_data' action).\"\n                            },\n                            \"element_selector\": {\n                                \"type\": \"string\",\n                                \"description\": \"CSS selector of the element to click (required for 'click_element' action).\"\n                            }\n                        }\n                    }\n                },\n                \"required\": [\"url\", \"action\"]\n            }\n        }\n    async def __call__(\n        self,\n        url: str,\n        action: Literal[\"read\", \"navigate\", \"download\", \"fill_form\", \"extract_data\", \"click_element\"],\n        params: Optional[Dict[str, Any]] = None\n    ) -> ToolResult:  \n        \"\"\"        Args:\n            url (str): The URL to perform the action on.\n            action (Literal[\"read\", \"navigate\", \"download\", \"fill_form\", \"extract_data\", \"click_element\"]): \n                The action to perform. Must be one of \"read\", \"navigate\", \"download\", \"fill_form\", \"extract_data\", \"click_element\".\n            params (Optional[Dict[str, Any]]): Optional parameters for the action. \n                - For \"download\", requires \"file_path\".\n                - For \"fill_form\", requires \"form_selector\" and \"form_data\".\n                - For \"extract_data\", requires \"data_selector\".\n                - For \"click_element\", requires \"element_selector\".\n        Returns:\n            ToolResult: A ToolResult object containing the output or error message.\n        Raises:\n            ValueError: If required parameters for the specified action are missing.\n            PlaywrightTimeoutError: If a timeout occurs while performing the action.\n            Exception: For any other errors that occur during the action.\n        Executes the specified action on the given URL with optional parameters.\n        Returns a ToolResult object containing the output or error message.\n        \"\"\"\n        params = params or {}\n        async with async_playwright() as p:\n            browser = await p.chromium.launch(headless=False)\n            context = await browser.new_context(storage_state=r\"C:\\mygit\\compuse\\computer_use_demo\\state.json\")\n            page = await context.new_page()\n\n            try:\n                result = None\n                if action == \"read\":\n                    result = await self.read_info(page, url)\n                elif action == \"navigate\":\n                    result = await self.navigate_website(page, url)\n                elif action == \"download\":\n                    file_path = params.get(\"file_path\")\n                    if not file_path:\n                        raise ValueError(\"Parameter `file_path` is required for action: download\")\n                    result = await self.download_file(page, url, file_path)\n                elif action == \"fill_form\":\n                    form_selector = params.get(\"form_selector\")\n                    form_data = params.get(\"form_data\")\n                    if not form_selector or not form_data:\n                        raise ValueError(\"Parameters `form_selector` and `form_data` are required for action: fill_form\")\n                    result = await self.fill_form(page, url, form_selector, form_data)\n                elif action == \"extract_data\":\n                    data_selector = params.get(\"data_selector\")\n                    if not data_selector:\n                        raise ValueError(\"Parameter `data_selector` is required for action: extract_data\")\n                    result = await self.extract_data(page, url, data_selector)\n                elif action == \"click_element\":\n                    element_selector = params.get(\"element_selector\")\n                    if not element_selector:\n                        raise ValueError(\"Parameter `element_selector` is required for action: click_element\")\n                    result = await self.click_element(page, url, element_selector)\n                else:\n                    raise ValueError(f\"Unrecognized action '{action}'\")\n                \n                return ToolResult(output=result)  # Return successful result\n\n            except PlaywrightTimeoutError:\n                error_msg = f\"Timeout occurred while performing action '{action}' on {url}.\"\n                logging.error(error_msg)\n                return ToolResult(error=error_msg)  # Return timeout error\n            except Exception as e:\n                error_msg = f\"An error occurred while performing action '{action}' on {url}: {str(e)}\"\n                #logging.error(error_msg)\n                return ToolResult(error=error_msg)  # Return general error\n            # finally:\n            #     await browser.close()\n\n    async def read_info(\n            self, \n            page, \n            url: str,\n            content_type: str = \"structured\",  # Options: \"raw\", \"cleaned\", \"text\", \"structured\"\n            selectors: Optional[List[str]] = None,  # CSS selectors to specifically target\n            exclude_selectors: Optional[List[str]] = None,  # CSS selectors to exclude\n            remove_scripts: bool = True,\n            remove_styles: bool = True,\n            remove_comments: bool = True,\n            preserve_links: bool = True,\n            max_length: Optional[int] = None\n        ) -> str:\n            \"\"\"\n            Reads and processes the content of the specified URL.\n            \n            Args:\n                page: Playwright page object\n                url: Target URL\n                content_type: Type of content processing to apply\n                selectors: List of CSS selectors to specifically target\n                exclude_selectors: List of CSS selectors to exclude\n                remove_scripts: Whether to remove script tags\n                remove_styles: Whether to remove style tags\n                remove_comments: Whether to remove HTML comments\n                preserve_links: Whether to preserve href attributes in the output\n                max_length: Maximum length of returned content\n            \"\"\"\n            await page.goto(url)\n            raw_html = await page.content()\n            self.session_history.append(f\"read_info: {url}\")\n            \n            # Create BeautifulSoup object for parsing\n            soup = BeautifulSoup(raw_html, 'html.parser')\n\n            if content_type == \"raw\":\n                return raw_html\n\n            # Remove unwanted elements\n            if remove_scripts:\n                for script in soup.find_all('script'):\n                    script.decompose()\n\n            if remove_styles:\n                for style in soup.find_all('style'):\n                    style.decompose()\n                # Remove inline styles\n                for tag in soup.find_all(style=True):\n                    del tag['style']\n\n            if remove_comments:\n                for comment in soup.find_all(string=lambda text: isinstance(text, Comment)):\n                    comment.extract()\n\n            # Remove tracking and analytics elements\n            tracking_classes = {'analytics', 'tracking', 'advertisement', 'ad-', 'cookie-banner'}\n            for element in soup.find_all(class_=lambda x: x and any(track in x.lower() for track in tracking_classes)):\n                element.decompose()\n\n            # Process based on content type\n            if content_type == \"cleaned\":\n                # Keep only specified selectors if provided\n                if selectors:\n                    new_soup = BeautifulSoup('', 'html.parser')\n                    for selector in selectors:\n                        for element in soup.select(selector):\n                            new_soup.append(element)\n                    soup = new_soup\n\n                # Remove excluded selectors\n                if exclude_selectors:\n                    for selector in exclude_selectors:\n                        for element in soup.select(selector):\n                            element.decompose()\n\n                # Clean up remaining HTML\n                for tag in soup.find_all(True):\n                    # Remove empty tags\n                    if len(tag.get_text(strip=True)) == 0 and tag.name not in ['img', 'br', 'hr']:\n                        tag.decompose()\n                        continue\n                    \n                    # Remove all attributes except href if preserve_links is True\n                    if preserve_links and tag.name == 'a':\n                        href = tag.get('href', '')\n                        tag.attrs = {'href': href} if href else {}\n                    else:\n                        tag.attrs = {}\n\n                content = str(soup)\n\n            elif content_type == \"text\":\n                # Extract only text content\n                content = soup.get_text(separator=' ', strip=True)\n                # Clean up whitespace\n                content = re.sub(r'\\s+', ' ', content)\n\n            elif content_type == \"structured\":\n                # Create a structured representation of the content\n                content = self._create_structured_content(soup)\n\n            else:\n                raise ValueError(f\"Unsupported content_type: {content_type}\")\n\n            # Truncate if max_length is specified\n            if max_length and len(content) > max_length:\n                content = content[:max_length] + \"...\"\n\n            logging.info(\"Read and processed content from '%s' using mode '%s'.\", url, content_type)\n            return content\n    def _create_structured_content(self, soup: BeautifulSoup) -> str:\n        \"\"\"\n        Creates a structured representation of the content.\n        \"\"\"\n        structure = []\n        \n        # Extract title\n        title = soup.title.string if soup.title else \"\"\n        if title:\n            structure.append(f\"Title: {title.strip()}\")\n\n        # Extract headings\n        headings = []\n        for tag in ['h1', 'h2', 'h3']:\n            for heading in soup.find_all(tag):\n                text = heading.get_text(strip=True)\n                if text:\n                    headings.append(f\"{tag.upper()}: {text}\")\n        if headings:\n            structure.append(\"\\nHeadings:\\n\" + \"\\n\".join(headings))\n\n        # Extract main content areas\n        main_content = soup.find('main') or soup.find('article') or soup.find('div', class_='content')\n        if main_content:\n            content_text = main_content.get_text(separator=' ', strip=True)\n            content_text = re.sub(r'\\s+', ' ', content_text)\n            structure.append(\"\\nMain Content:\\n\" + content_text)\n\n        # Extract links\n        links = []\n        for link in soup.find_all('a', href=True):\n            text = link.get_text(strip=True)\n            href = link['href']\n            if text and href:\n                links.append(f\"- {text}: {href}\")\n        if links:\n            structure.append(\"\\nLinks:\\n\" + \"\\n\".join(links))\n\n        return \"\\n\\n\".join(structure)\n    async def navigate_website(self, page, url: str) -> str:\n        \"\"\"\n        Navigates to the specified URL and returns the page title.\n        \"\"\"\n        await page.goto(url)\n        title = await page.title()\n        self.session_history.append(f\"navigate: {url}\")\n        logging.info(\"Navigated to '%s' with title '%s'.\", url, title)\n        return f\"Navigated to {url}. Page title: {title}\"\n\n    async def download_file(self, page, url: str, file_path: str) -> str:\n        \"\"\"\n        Downloads a file from the specified URL and saves it to the given file path.\n        \"\"\"\n        os.makedirs(self.download_dir, exist_ok=True)\n        async with page.expect_download() as download_info:\n            await page.goto(url)\n        download = await download_info.value\n        save_path = os.path.join(self.download_dir, file_path)\n        await download.save_as(save_path)\n        self.session_history.append(f\"download_file: {save_path}\")\n        logging.info(\"Downloaded file from '%s' to '%s'.\", url, save_path)\n        return f\"File downloaded and saved to {save_path}\"\n\n    async def fill_form(self, page, url: str, form_selector: str, form_data: Dict[str, str]) -> str:\n        \"\"\"\n        Fills out a form identified by form_selector with the provided form_data.\n        \"\"\"\n        await page.goto(url)\n        for field, value in form_data.items():\n            await page.fill(f\"{form_selector} {field}\", value)\n        await page.click(f\"{form_selector} button[type='submit']\")\n        self.session_history.append(f\"fill_form: {url} with {form_data}\")\n        logging.info(\"Filled form on '%s' with data '%s'.\", url, form_data)\n        return f\"Form on {url} filled with provided data and submitted.\"\n\n    async def extract_data(self, page, url: str, data_selector: str) -> str:\n        \"\"\"\n        Extracts and returns data from the specified selector on the webpage.\n        \"\"\"\n        await page.goto(url)\n        data = await page.inner_text(data_selector)\n        self.session_history.append(f\"extract_data: {url} - {data_selector}\")\n        logging.info(\"Extracted data from '%s' using selector '%s'.\", url, data_selector)\n        return data\n\n    async def click_element(self, page, url: str, element_selector: str) -> str:\n        \"\"\"\n        Clicks an element identified by the selector on the webpage.\n        \"\"\"\n        await page.goto(url)\n        await page.click(element_selector)\n        self.session_history.append(f\"click_element: {url} - {element_selector}\")\n        logging.info(\"Clicked element '%s' on '%s'.\", element_selector, url)\n        return f\"Clicked element '{element_selector}' on {url}.\"\n\n    def integrate_external_api(self, api_url: str, params: Optional[Dict[str, Any]] = None) -> Any:\n        \"\"\"\n        Integrates with an external API and returns the response.\n        \"\"\"\n        params = params or {}\n        headers = {\n            \"Authorization\": f\"Bearer {self.api_credentials.get('api_key', '')}\",\n            \"Content-Type\": \"application/json\"\n        }\n        response = requests.get(api_url, headers=headers, params=params)\n        if response.status_code == 200:\n            logging.info(\"Successfully integrated with external API '%s'.\", api_url)\n            return response.json()\n        else:\n            logging.error(\"Failed to integrate with external API '%s'. Status code: %s\", api_url, response.status_code)\n            raise ConnectionError(f\"Failed to connect to external API '{api_url}'. Status code: {response.status_code}\")\n\n    def get_session_history(self) -> str:\n        \"\"\"\n        Returns the session history for contextual awareness.\n        \"\"\"\n        history = \"\\n\".join(self.session_history)\n        logging.info(\"Session history retrieved.\")\n        return history\n",
        "version": 1,
        "last_modified": "2024-11-20T20:46:15.560130",
        "dependencies": [],
        "description": "A simple module"
    },
    "run.py": {
        "name": "run.py",
        "content": "## run.py\n\"\"\"Utility to run shell commands asynchronously with a timeout.\"\"\"\n\nimport asyncio\n\nTRUNCATED_MESSAGE: str = \"<response clipped><NOTE>To save on context only part of this file has been shown to you. You should retry this tool after you have searched inside the file the line numbers of what you are looking for. Remember to use you are working in Windows.</NOTE>\"\nMAX_RESPONSE_LEN: int = 16000\n\n\ndef maybe_truncate(content: str, truncate_after: int | None = MAX_RESPONSE_LEN):\n    \"\"\"Truncate content and append a notice if content exceeds the specified length.\"\"\"\n    return (\n        content\n        if not truncate_after or len(content) <= truncate_after\n        else content[:truncate_after] + TRUNCATED_MESSAGE\n    )\n\n\nasync def run(\n    cmd: str,\n    timeout: float | None = 120.0,  # seconds\n    truncate_after: int | None = MAX_RESPONSE_LEN,\n):\n    \"\"\"Run a shell command asynchronously with a timeout.\"\"\"\n    process = await asyncio.create_subprocess_shell(\n        cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE\n    )\n\n    try:\n        stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\n        return (\n            process.returncode or 0,\n            maybe_truncate(stdout.decode(), truncate_after=truncate_after),\n            maybe_truncate(stderr.decode(), truncate_after=truncate_after),\n        )\n    except asyncio.TimeoutError as exc:\n        try:\n            process.kill()\n        except ProcessLookupError:\n            pass\n        raise TimeoutError(\n            f\"Command '{cmd}' timed out after {timeout} seconds\"\n        ) from exc\n",
        "version": 1,
        "last_modified": "2024-11-20T20:46:15.561520",
        "dependencies": [],
        "description": "A simple module"
    },
    "windows_navigation.py": {
        "name": "windows_navigation.py",
        "content": "# tools/windows_navigation.py\n\nimport pyautogui\nimport time\nfrom typing import Literal, Optional, Dict, Any\nfrom pathlib import Path\nimport json\nimport logging\nfrom .base import BaseAnthropicTool, ToolResult, ToolError\nfrom rich import print as rr\n\n# Configure logging\nlogging.basicConfig(level=logging.CRITICAL)\nlogger = logging.getLogger(__name__)\n\nclass WindowsNavigationTool:\n    \"\"\"\n    A tool specializing in navigating Windows and Windows applications using keyboard shortcuts.\n    \"\"\"\n\n    name: Literal[\"windows_navigate\"] = \"windows_navigate\"\n    api_type: Literal[\"custom\"] = \"custom\"\n    description: str = (\n        \"A comprehensive tool for Windows navigation using keyboard shortcuts. \"\n        \"Supports window management, file operations, system controls, and accessibility features. \"\n        \"Uses pyautogui to simulate keyboard and mouse inputs for automated Windows control.\"\n    )\n\n    def __init__(self):\n        \"\"\"Initialize the WindowsNavigationTool with shortcuts configuration.\"\"\"\n        self.shortcuts_file = Path(__file__).parent / \"windows_shortcuts.json\"\n        self.shortcuts = self._load_shortcuts()\n        self.session_history = []  # Track navigation actions\n        logging.info(\"WindowsNavigationTool initialized with shortcuts from '%s'\", self.shortcuts_file)\n\n    def _load_shortcuts(self) -> Dict[str, Any]:\n        \"\"\"Load keyboard shortcuts from JSON file.\"\"\"\n        try:\n            if self.shortcuts_file.exists():\n                with open(self.shortcuts_file, 'r') as f:\n                    return json.load(f)\n            else:\n                logger.warning(f\"Shortcuts file not found at {self.shortcuts_file}\")\n                return {}\n        except Exception as e:\n            logger.error(f\"Error loading shortcuts: {e}\")\n            return {}\n\n    def to_params(self) -> dict:\n        \"\"\"Define the parameters for the tool.\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"type\": self.api_type,\n            \"input_schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"action\": {\n                        \"type\": \"string\",\n                        \"enum\": [\n                            # Window Management\n                            \"switch_window\", \"open_start_menu\", \"minimize_window\", \n                            \"maximize_window\", \"restore_window\", \"close_window\", \n                            \"take_screenshot\", \"go_to_desktop\",\n                            \"switch_virtual_desktop_left\", \"switch_virtual_desktop_right\",\n                            \n                            # File Explorer\n                            \"open_file_explorer\", \"refresh_explorer\",\n                            \n                            # Taskbar\n                            \"open_task_manager\", \"lock_workstation\", \"sign_out\", \n                            \"hibernate\", \"sleep\",\n                            \n                            # Clipboard Operations\n                            \"copy\", \"paste\", \"cut\", \"select_all\",\n                            \n                            # System Controls\n                            \"open_run_dialog\", \"open_settings\", \"open_search\",\n                            \n                            # Accessibility\n                            \"toggle_high_contrast\", \"toggle_narrator\", \"toggle_magnifier\"\n                        ],\n                        \"description\": \"The Windows action to perform\"\n                    },\n                    \"modifier\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"ctrl\", \"alt\", \"shift\", \"win\"],\n                        \"description\": \"Optional modifier key(s)\"\n                    },\n                    \"target\": {\n                        \"type\": \"string\",\n                        \"description\": \"Optional target for the action (e.g., window title)\"\n                    }\n                },\n                \"required\": [\"action\"]\n            }\n        }\n\n    async def __call__(\n        self,\n        action: str,\n        modifier: Optional[str] = None,\n        target: Optional[str] = None\n    ) -> ToolResult:\n        \"\"\"\n        Execute the requested Windows action.\n        \n        Args:\n            action (str): The action to perform (must be one of the defined actions)\n            modifier (Optional[str]): Optional modifier key(s)\n            target (Optional[str]): Optional target for the action\n            \n        Returns:\n            ToolResult: Contains either the success output or error message\n        \"\"\"\n        try:\n            # Get shortcut configuration\n            shortcut = self.shortcuts.get(action)\n            if not shortcut:\n                return ToolResult(error=f\"Unknown action: {action}\")\n\n            # Prepare keys sequence\n            keys = shortcut[\"keys\"]\n            if modifier:\n                keys = [modifier] + keys\n\n            # Execute the shortcut\n            result = await self._execute_action(action, keys, target)\n            \n            # Log the action\n            self.session_history.append(f\"{action}: {result.output if result.output else result.error}\")\n            \n            return result\n\n        except Exception as e:\n            error_msg = f\"Error executing {action}: {str(e)}\"\n            logger.error(error_msg)\n            return ToolResult(error=error_msg)\n\n    async def _execute_action(self, action: str, keys: list, target: Optional[str] = None) -> ToolResult:\n        \"\"\"Execute a Windows action with the given keys and target.\"\"\"\n        try:\n            # Activate window if needed\n            if target and \"window\" in action.lower():\n                windows = pyautogui.getWindowsWithTitle(target)\n                if not windows:\n                    return ToolResult(error=f\"No window found with title '{target}'\")\n                windows[0].activate()\n                time.sleep(0.5)\n\n            # Execute the key combination\n            pyautogui.hotkey(*keys)\n            time.sleep(0.1)  # Small delay for action to complete\n\n            # Handle any follow-up input\n            if target and self.shortcuts.get(action, {}).get(\"requires_target\", False):\n                pyautogui.typewrite(target)\n                pyautogui.press('enter')\n\n            success_msg = f\"Successfully executed '{action}'\"\n            if target:\n                success_msg += f\" with target '{target}'\"\n            \n            logger.info(success_msg)\n            return ToolResult(output=success_msg)\n\n        except Exception as e:\n            error_msg = f\"Failed to execute {action}: {str(e)}\"\n            logger.error(error_msg)\n            return ToolResult(error=error_msg)\n\n    def get_session_history(self) -> str:\n        \"\"\"Returns the session history of navigation actions.\"\"\"\n        return \"\\n\".join(self.session_history)",
        "version": 1,
        "last_modified": "2024-11-20T20:46:15.577411",
        "dependencies": [],
        "description": "A simple module"
    },
    "__init__.py": {
        "name": "__init__.py",
        "content": "from .base import BaseAnthropicTool, ToolError, ToolResult\nfrom .bash import BashTool\nfrom .computer import ComputerTool\nfrom .edit import EditTool\nfrom .collection import ToolCollection\nfrom .expert import GetExpertOpinionTool\nfrom .playwright import WebNavigatorTool\nfrom .gotourl_reports import GoToURLReportsTool\nfrom .windows_navigation import WindowsNavigationTool\n\n__all__ = [\n    \"BaseAnthropicTool\",\n    \"ToolError\",\n    \"ToolResult\",\n    \"BashTool\",\n    \"ComputerTool\",\n    \"EditTool\",\n    \"ToolCollection\",\n    \"GetExpertOpinionTool\",\n    \"WebNavigatorTool\",\n    \"GoToURLReportsTool\",\n    \"WindowsNavigationTool\"\n]\n\n",
        "version": 1,
        "last_modified": "2024-11-20T20:46:15.579002",
        "dependencies": [],
        "description": "A simple module"
    },
    "test_form.py": {
        "name": "test_form.py",
        "content": "from .base import BaseAnthropicTool, ToolError, ToolResult\nfrom .bash import BashTool\nfrom .computer import ComputerTool\nfrom .edit import EditTool\nfrom .collection import ToolCollection\nfrom .expert import GetExpertOpinionTool\nfrom .playwright import WebNavigatorTool\nfrom .gotourl_reports import GoToURLReportsTool\nfrom .windows_navigation import WindowsNavigationTool\n\n__all__ = [\n    \"BaseAnthropicTool\",\n    \"ToolError\",\n    \"ToolResult\",\n    \"BashTool\",\n    \"ComputerTool\",\n    \"EditTool\",\n    \"ToolCollection\",\n    \"GetExpertOpinionTool\",\n    \"WebNavigatorTool\",\n    \"GoToURLReportsTool\",\n    \"WindowsNavigationTool\"\n]\n\n",
        "version": 1,
        "last_modified": "2024-11-20T20:51:33.291808",
        "dependencies": [],
        "description": "A simple module"
    }
}